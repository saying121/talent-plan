<!--toc:start-->

- [5.1 Raft基础](#51-raft基础)
- [5.3 日志复制](#53-日志复制)
<!--toc:end-->

# 5.1 Raft基础

开始选举时，跟随者增加当前的任期号并切换成候选者状态。
然后投给自己一票，并向集群中的其他服务器并行发送RequestVote RPC。
候选者在以下任意事件发生前保持候选者状态:
(a) 赢得选举;
(b) 其他服务器声称自己是领导者;
(c)一段时间过去了，没人赢得选举。

任意一台服务器在同一个任期号只能投给最多一个候选者，基于先到先得的原则(注意: 5.4节在投票时添加了额外一项约束)。
一旦赢得选举，则变成领导者。然后向所有其他服务器发送心跳包通知大家防止新的选举产生。

在等候选举结果时，候选者可能会收到其他声称自己为领导者的服务器发来的AppendEntries RPC消息。
如果RPC中包含的领导者任期大于等于候选者的当前任期，则会把这个领导者当成合法的领导者，并将自己转化为跟随者状态。
如果比自己的任期小，则拒绝这个RPC消息，并继续维持候选者状态。

没人赢得选举:
这种情况发生时，所有的候选者将会超时，然后增加自己的任期号开始新一轮的选举投票。如果没有额外的机制，这种情况将会一直发生，无限重复下去。

选举超时是从一个时长范围内(例如150-300ms)随机选取的。
使用一个随机的选举超时重新计时，最先超时的那个候选者开始新一轮选举，这减少了选举分裂情况的发生。

# 5.3 日志复制

一旦领导者产生，他将开始处理客户端请求。
每一个请求都包含有一条供 复制状态机执行的指令。
领导者将这条指令做为新的日志条目追加到自己的日志中，然后并行地向所有服务器发送AppendEntries RPC来复制这条日志记录。

当这条记录被安全地复制(后面将描述这个概念)，领导者就会将这条记录应用于状态机并返回结果给客户端。
如果跟随者出现崩溃(crash)或者运行缓慢或者出现丢包，
领导者将一直重试AppendEntries RPC请求(即使在响应了客户端请求之后)直到所有的跟随者都保存了所有的日志记录。

每一条日志 记录保存了 **状态机指令** 和 领导者接收到这个指令时的 **任期号**。
每一条日志 记录也有一个 **整数索引** 标识他在日志中的位置。

一条日志条目一旦被创建他的领导者 **复制到多数服务器** 上，则这条日志条目将被提交。
这也会将此条日志**之前的所有日志记录都提交**，**包括之前任期的日志记录**。

领导者决定了何时可以**将某条日志条目应用于状态机**
领导者跟踪记录他所知道的已经提交的**最大索引**，
并包含在后续发送的AppendEntries RPC(包括心跳)，
其他的服务器就能了解到这个信息。
一旦跟随者收到**某条日志记录已经提交**，则将此记录**应用于本地的状态机中**(按照日志顺序)。

当发送AppendEntries RPC时，除了 **带上新的日志条目** 外，还会将 **领导者日志里的索引和任期号** 带上。
跟随者如果在日志中 **没有找到此索引和任期号对应的日志记录** ，则 **拒绝这条新记录**。

Raft处理不致性的方法是 **强制跟随者复制领导者的日志** 。这意味着跟随者中**冲突的日志将被领导者的日志覆盖**。
5.4节我们将介绍当加上一个限制时，这种操作方式是安全的。

如果某一个跟随者日志与此不一致，则AppendEntries的一致性检查将会失败。
在领导者收到 AppendEntries 的 **拒绝回复** 后，领导者将减少 nextIndex 的值，并 **重试** AppendEntries RPC。
最终 nextIndex 将会到达之前提到的两个日志一致的那个索引点。
这时， AppendEntries 将会成功，跟随者移除这个索引之后的所有日志，并追加领导者发过来的日志记录(如果有的话)。
一但 AppendEntries 成功，跟随者与领导者的日志将达成一致，并且在这个任期内都将保持同步。

在跟随者拒绝 AppendEntries 请求的时候，可以带上冲突的任期号和这个任期号的第一个索引值。
有了这个信息，领导者可以跳过这个任期内冲突的日志索引;
这样任何冲突任期只需要一次 AppendEntries RPC 请求，而非原来的每一条日志记录一条RPC请求。

# 5.4.1 选举限制

Raft限制了只有包含 **所有已经提交的日志** 的候选人才能赢得选举。
RPC请求中包含了 **候选人的日志信息**，其他服务如果发现自己的日志 **比候选人更新**，则 **拒绝投票** 给这个候选人。
Raft通过比较两条 **日志的索引和任期** 来确认谁更新。
如果两条日志记录 **含有不一样的任期号** ，则 **大的任期号更新**。如果任期号相同，则 **日志更多的那一方更新**。

- 两份日志最后条目 term 不同，term 大的新。
- 两份日志最后条目 term 相同，log 长的新。

# 5.4.2 提交之前任期的记录

在**当前任期内**，领导者**能够通过某条记录是否已经被大多数服务器保存**，来确认这条日志是否可以提交。
当领导者在提交记录之前崩溃了，后面的领导者将**会尝试完成复制这些日志记录**的任务。
然而，一个领导人**不能断定**一个之前任期里的**日志条目被保存到大多数服务器上的时候就一定已经提交了**。

# 5.5 跟随者和候选者崩溃

如果跟随者或者候选者崩溃，那么后续的RequestVote和AppendEntries将会失败。
Raft会在这些失败后不断地重试，如果失败的机器重启了，那么RPC就会成功了。
如果一台服务器已经处理完了RPC请求，但在回复的时候崩溃了，那么他将在重启成功后重复收到这个包。
Raft的RPC请求是幂等的，所以不会产生问题。
收到一条已经在自己日志里的AppendEntries请求，他将忽略这些记录。

# 5.6 时序和可用性

安全性不依赖与时序: 一些事件的较快发生或者较慢发生，不会引发系统产生不正确的结果。
可用性(系统可以在规定时间内响应客户端请求)不可避免地需要依赖于时序。

0.5-20ms,10-500ms
broadcastTime << electionTimeout << MTBF

- broadcastTime 是一台服务器并行向集群中所有其他服务器发送RPC请求并且收到他们回复的平均时间;
- electionTimeout 就是5.2节里所介绍的选举超时;
- MTBF 是服务器崩溃的平均时长。

broadcastTime 和MTBF是底层系统的属性， electionTimeout 则是我们 **人为选择** 的一个值。
Raft 的 RPC 需要将信息或者日志记录持久化到存储中，所以一般 broadcastTime 大概会在0.5ms到20ms不等，取决于存储技术。
所以 electionTimeout 一般是介于*10ms*到*500ms*之间的一个值。一般服务器的 MTBF 为几个月或者更长，所以很容易满足时序要求。
